# Dependency Manager Playbook

> **Purpose**: Manage NPM packages, Node.js runtime, Docker images, and external service dependencies with risk-aware validation workflows
> **Version**: 1.2
> **Last Updated**: 2025-12-30

---

## Mental Model

Dependency management operates across 4 risk tiers:

```
User Request ‚Üí Risk Assessment ‚Üí Update Strategy ‚Üí Validation ‚Üí Commit
                    ‚Üì
         LOW: Automated (patches)
         MEDIUM: Validated (minor versions)
         HIGH: Manual review (major versions, critical SDKs)
         EMERGENCY: Fast-track (security fixes)
```

**Risk Tiers**:
- **LOW**: Patch versions (1.2.3 ‚Üí 1.2.4), automated updates
- **MEDIUM**: Minor versions (1.2.x ‚Üí 1.3.0), ESLint, Vitest, TypeScript
- **HIGH**: Major versions (1.x ‚Üí 2.0), MCP SDK, Typesense, Node runtime
- **EMERGENCY**: Critical security vulnerabilities (CVE fixes)

---

## Inputs / Outputs

**Inputs**:
- Command variant (check, update, align, security)
- Optional: Package name, version constraint, flags (--safe, --force, --validate)

**Outputs**:
- Status reports (outdated packages, security vulns, version misalignments)
- Updated dependency files (package.json, package-lock.json, .nvmrc, Dockerfile)
- Validation results (tests, type checks, linting)
- Commit-ready changes

---

## Canonical Dependency Files

### Primary Files (Auto-Updated)
- `package-lock.json` - **NEVER manually edit** (auto-generated by npm)
- `node_modules/` - Managed by npm (not committed)

### Source of Truth Files (Manual Edits Required)
- `package.json` - NPM package definitions
- `.nvmrc` - Node version for nvm
- `Dockerfile` (lines 2, 15) - Docker base image versions
- `docker-compose.typesense.yml` (line 3) - Typesense image version

### Configuration Files (Version-Dependent)
- `tsconfig.json` - TypeScript compiler options
- `vitest.config.ts` - Test runner config
- `eslint.config.js` - Linter config

---

## PLAY: Dry-Run Preview

**Goal**: Preview changes without modifying any files (safe preview mode)

**Trigger**: Any update command with `--dry-run` flag

**Examples**:
- `/dependency-updater update-safe --dry-run`
- `/dependency-updater update typescript --dry-run`
- `/dependency-updater align-versions --dry-run`

**Algorithm**:
1. Identify requested operation (update-safe, update <package>, align-versions, etc.)
2. Scan for what WOULD change (same logic as actual operation, but read-only)
3. Classify each change by risk tier
4. Show which files WOULD be modified
5. Display validation steps that WOULD run
6. Report NO file modifications, NO git operations

**Output Format**:
```
üîç DRY-RUN PREVIEW: <operation>

üìã CHANGES PLANNED:
‚îú‚îÄ package.json
‚îÇ  ‚îú‚îÄ typescript: 5.3.3 ‚Üí 5.4.2 (MEDIUM risk)
‚îÇ  ‚îî‚îÄ vitest: 1.0.0 ‚Üí 2.0.0 (MEDIUM risk)
‚îú‚îÄ package-lock.json (auto-regenerated)
‚îî‚îÄ No other files modified

‚öôÔ∏è VALIDATION STEPS:
1. npm install (regenerate lockfile)
2. npm run typecheck (TypeScript validation)
3. npm run lint (ESLint validation)
4. npm test (Test suite)

‚ö†Ô∏è RISK ASSESSMENT:
- MEDIUM risk changes: 2 packages
- Validation time: ~2-3 minutes
- Rollback: Automated via git restore

üìä ESTIMATED IMPACT:
- Files changed: 2 (package.json, package-lock.json)
- Tests to run: ~150 tests
- Token cost: ~5K (Sonnet validation)

‚úÖ TO EXECUTE: Run same command without --dry-run
‚ùå TO CANCEL: No action needed (no changes made)
```

**Validation**:
- MUST NOT modify any files
- MUST NOT run npm install (read package.json only)
- MUST NOT commit changes
- MUST accurately predict what would happen

**Error Handling**:
- If operation invalid ‚Üí Report error, suggest correct syntax
- If no changes needed ‚Üí Report "Already up to date"

---

## PLAY: Check Status

**Goal**: Show current dependency status across all systems

**Trigger**: `/deps check` or `/deps status`

**Algorithm**:
1. Run `npm outdated` ‚Üí Capture outdated packages
2. Run `npm audit` ‚Üí Capture security vulnerabilities
3. Check Node version alignment:
   ```bash
   nvmrc_version=$(cat .nvmrc)
   dockerfile_version=$(grep "FROM node:" Dockerfile | head -1 | sed 's/.*node:\([0-9]*\).*/\1/')
   package_min=$(grep '"node":' package.json | sed 's/.*>=\([0-9]*\).*/\1/')

   if [ "$nvmrc_version" != "$dockerfile_version" ] || [ "$nvmrc_version" != "$package_min" ]; then
     echo "‚ö†Ô∏è Node version mismatch detected"
   fi
   ```
4. Check Typesense version alignment:
   ```bash
   typesense_docker=$(grep "typesense/typesense:" docker-compose.typesense.yml | sed 's/.*:\(.*\)/\1/')
   typesense_npm=$(grep '"typesense":' package.json | sed 's/.*\^\([0-9.]*\).*/\1/')
   ```
5. Format output:
   ```
   üì¶ DEPENDENCY STATUS

   üî¥ OUTDATED (X packages):
   - package@current ‚Üí latest (risk: LOW/MEDIUM/HIGH)

   üîí SECURITY (X vulnerabilities):
   - CVE-XXXX: package@version (severity: HIGH/MEDIUM/LOW)

   ‚öôÔ∏è VERSION ALIGNMENT:
   - Node: .nvmrc=20, Dockerfile=22, package.json>=18 [MISALIGNED]
   - Typesense: Docker=27.1, NPM=1.8.2 [OK]

   ‚úÖ VALIDATION STATUS:
   - Tests: PASSING
   - Type check: PASSING
   - Linting: PASSING
   ```

**Output**: Status report with actionable recommendations

**Validation**:
- All status checks complete without errors
- Misalignments clearly flagged
- Risk levels assigned to each outdated package

---

## PLAY: Update Safe (Automated)

**Goal**: Update patch versions (low-risk, automated)

**Trigger**: `/deps update --safe`

**Algorithm**:
1. **Pre-flight check**:
   ```bash
   if [ -n "$(git status --porcelain)" ]; then
     echo "‚ö†Ô∏è Uncommitted changes detected. Commit or stash first."
     exit 1
   fi
   ```
2. **Backup current state**:
   ```bash
   cp package.json package.json.backup
   cp package-lock.json package-lock.json.backup
   ```
3. **Run safe update**:
   ```bash
   npm update  # Respects semver, patch versions only
   ```
4. **Validate**:
   - Run `npm run typecheck` ‚Üí Must pass
   - Run `npm run lint` ‚Üí Must pass
   - Run `npm test` ‚Üí Must pass
5. **Report changes**:
   ```bash
   git diff package.json package-lock.json
   ```
6. **If all pass**: Commit changes
7. **If any fail**: Rollback
   ```bash
   mv package.json.backup package.json
   mv package-lock.json.backup package-lock.json
   npm install
   ```

**Output**: Updated package files or rollback

**Invariants**:
- MUST run validation before committing
- MUST rollback on any validation failure
- MUST commit package.json + package-lock.json together

---

## PLAY: Update Risky (Manual Review)

**Goal**: Update minor/major versions with full validation workflow

**Trigger**: `/deps update <package>[@version] [--validate]`

**Risk Assessment**:
```
if package in ["@modelcontextprotocol/sdk", "typesense"]:
    risk = HIGH
elif package in ["typescript", "eslint", "vitest"]:
    risk = MEDIUM
else:
    risk = LOW
```

**Algorithm**:

1. **Identify risk level**:
   - HIGH: MCP SDK, Typesense, Node runtime, Anthropic SDK
   - MEDIUM: TypeScript, ESLint, Vitest
   - LOW: Other packages

2. **Check changelog** (if HIGH or MEDIUM):
   - MCP SDK: https://github.com/modelcontextprotocol/sdk/releases
   - Typesense: https://github.com/typesense/typesense/releases
   - TypeScript: https://github.com/microsoft/TypeScript/releases
   - Anthropic: https://github.com/anthropics/anthropic-sdk-typescript/releases

3. **Display changelog summary**:
   ```
   üìã CHANGELOG for <package> (<current> ‚Üí <target>):

   Breaking Changes:
   - [List breaking changes]

   New Features:
   - [List new features]

   Bug Fixes:
   - [List fixes]
   ```

4. **Prompt for confirmation** (if HIGH risk):
   ```
   ‚ö†Ô∏è HIGH RISK UPDATE

   This package requires careful testing:
   - Run integration tests
   - Test with real MCP clients (if MCP SDK)
   - Verify API compatibility (if Anthropic SDK)

   Proceed? (y/n)
   ```

5. **Perform update**:
   ```bash
   npm install <package>@<version>
   ```

6. **Run risk-specific validation**:
   - **HIGH (MCP SDK)**:
     ```bash
     npm run test:integration
     # Test with Claude Code CLI
     claude --version  # Verify MCP server still loads
     ```
   - **HIGH (Typesense)**:
     ```bash
     npm run test:contract  # Typesense-specific tests
     docker-compose -f docker-compose.typesense.yml up -d
     # Verify search still works
     ```
   - **HIGH (Anthropic SDK)**:
     ```bash
     npm run codex:prompt  # Test Codex execution
     ```
   - **MEDIUM (TypeScript)**:
     ```bash
     npm run typecheck
     # Review any new type errors
     ```
   - **ALL**:
     ```bash
     npm run typecheck && npm run lint && npm test
     ```

7. **Report validation results**:
   ```
   ‚úÖ Type check: PASSED
   ‚úÖ Linting: PASSED
   ‚úÖ Tests: PASSED (X/X)
   ‚úÖ Integration tests: PASSED
   ```

8. **Commit if all pass**, else rollback

**Output**: Updated package with validation results

**Invariants**:
- HIGH-risk updates MUST run integration tests
- MCP SDK updates MUST test with real client
- Typesense updates MUST run contract tests
- ALL updates MUST pass base validation (typecheck, lint, test)

---

## PLAY: Align Versions

**Goal**: Synchronize Node.js version across .nvmrc, package.json, Dockerfile

**Trigger**: `/deps align-node <version>`

**Algorithm**:
1. **Validate version format**:
   ```bash
   if ! [[ "$version" =~ ^[0-9]+$ ]]; then
     echo "‚ùå Version must be major version number (e.g., 20, 22)"
     exit 1
   fi
   ```

2. **Update .nvmrc**:
   ```bash
   echo "$version" > .nvmrc
   ```

3. **Update package.json engines field**:
   ```json
   "engines": {
     "node": ">=$version.0.0"
   }
   ```

4. **Update Dockerfile (2 occurrences)**:
   ```bash
   sed -i "s/FROM node:[0-9]*/FROM node:$version/" Dockerfile
   ```

5. **Verify alignment**:
   ```bash
   nvmrc=$(cat .nvmrc)
   dockerfile=$(grep "FROM node:" Dockerfile | head -1 | sed 's/.*node:\([0-9]*\).*/\1/')
   package=$(grep '"node":' package.json | sed 's/.*>=\([0-9]*\).*/\1/')

   if [ "$nvmrc" == "$version" ] && [ "$dockerfile" == "$version" ] && [ "$package" == "$version" ]; then
     echo "‚úÖ Node version aligned to $version"
   else
     echo "‚ùå Alignment failed"
     exit 1
   fi
   ```

6. **Test with new version**:
   ```bash
   nvm use  # Should load Node $version from .nvmrc
   node --version  # Verify

   docker-compose build  # Rebuild with new Node version
   ```

7. **Commit changes**:
   ```bash
   git add .nvmrc package.json Dockerfile
   git commit -m "chore(deps): align Node version to $version

   - Updated .nvmrc: $version
   - Updated package.json engines: >=$version.0.0
   - Updated Dockerfile base images: node:$version-alpine"
   ```

**Output**: Aligned Node version across all files

**Validation**:
- All 3 files reference same major version
- Docker build succeeds
- Node version verification passes

---

## PLAY: Verify Docker Dependencies

**Goal**: Ensure Docker images have required dependencies, especially for HEALTHCHECK commands

**Trigger**: After Dockerfile base image changes, version bumps, or when adding/modifying HEALTHCHECK

**Universal Problem**:
Minimal base images (Alpine, slim variants, distroless) exclude common utilities like `curl`, `wget`, `nc`. HEALTHCHECK commands that assume these tools exist will fail at runtime, not build time. This is a **silent failure mode** that only appears in production.

**Algorithm**:

1. **Extract HEALTHCHECK command from Dockerfile**:
   ```bash
   # Parse HEALTHCHECK CMD line
   HEALTHCHECK_CMD=$(grep "HEALTHCHECK" Dockerfile | grep -oP '(?<=CMD ).*?(?= \|\||$)' | awk '{print $1}')

   # Common patterns:
   # - curl -f http://localhost:3000/health
   # - wget --spider http://...
   # - nc -z localhost 5432
   ```

2. **Extract production base image** (multi-stage builds use last FROM):
   ```bash
   BASE_IMAGE=$(grep "^FROM" Dockerfile | tail -1 | awk '{print $2}')
   echo "Production base image: $BASE_IMAGE"
   ```

3. **Test if health check tool exists in base image**:
   ```bash
   echo "Testing: $HEALTHCHECK_CMD in $BASE_IMAGE"
   docker run --rm $BASE_IMAGE which $HEALTHCHECK_CMD

   if [ $? -ne 0 ]; then
     echo "‚ùå HEALTHCHECK will fail at runtime"
     echo "Tool '$HEALTHCHECK_CMD' not found in $BASE_IMAGE"
   else
     echo "‚úÖ Health check tool available"
   fi
   ```

4. **Identify required package installation by base image type**:
   ```bash
   # Determine package manager and install command
   if [[ "$BASE_IMAGE" == *"alpine"* ]]; then
     PKG_MANAGER="apk"
     INSTALL_CMD="RUN apk add --no-cache $HEALTHCHECK_CMD"
   elif [[ "$BASE_IMAGE" == *"debian"* ]] || [[ "$BASE_IMAGE" == *"ubuntu"* ]]; then
     PKG_MANAGER="apt-get"
     INSTALL_CMD="RUN apt-get update && apt-get install -y $HEALTHCHECK_CMD && rm -rf /var/lib/apt/lists/*"
   elif [[ "$BASE_IMAGE" == *"centos"* ]] || [[ "$BASE_IMAGE" == *"rhel"* ]] || [[ "$BASE_IMAGE" == *"fedora"* ]]; then
     PKG_MANAGER="yum"
     INSTALL_CMD="RUN yum install -y $HEALTHCHECK_CMD && yum clean all"
   else
     PKG_MANAGER="unknown"
     INSTALL_CMD="# Unknown base image - verify health check tool manually"
   fi
   ```

5. **Report findings and required fix**:
   ```
   ‚ö†Ô∏è DOCKER HEALTHCHECK DEPENDENCY VERIFICATION

   Base Image: $BASE_IMAGE
   HEALTHCHECK Command: $HEALTHCHECK_CMD
   Tool Status: NOT FOUND in base image
   Package Manager: $PKG_MANAGER

   Required Fix (add to Dockerfile after FROM statement):

   FROM $BASE_IMAGE
   $INSTALL_CMD  # ‚Üê Add this line
   WORKDIR /app
   ...

   Example for Alpine:
   FROM node:22-alpine
   RUN apk add --no-cache curl  # Required for HEALTHCHECK
   WORKDIR /app
   ```

6. **Validate fix** (after manual Dockerfile edit):
   ```bash
   # Rebuild image
   docker build -t healthcheck-validation-test .

   # Verify tool is now available
   docker run --rm healthcheck-validation-test which $HEALTHCHECK_CMD

   # Should exit with code 0
   if [ $? -eq 0 ]; then
     echo "‚úÖ Health check dependency verified"
   else
     echo "‚ùå Health check dependency still missing"
     exit 1
   fi

   # Clean up test image
   docker rmi healthcheck-validation-test
   ```

**Common Health Check Tools by Base Image**:

| Base Image Pattern | curl | wget | nc | bash | Package Manager | Typical Install |
|-------------------|------|------|-------|------|----------------|-----------------|
| `*-alpine` | ‚ùå | ‚ùå | ‚ùå | ‚ùå | apk | `RUN apk add --no-cache curl bash` |
| `*-slim` | ‚úÖ* | ‚ùå | ‚ùå | ‚úÖ | apt-get | Usually included, verify |
| `debian:*` | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | apt-get | Usually included |
| `ubuntu:*` | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | apt-get | Usually included |
| `centos:*` / `rhel:*` | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | yum/dnf | Usually included |
| `distroless/*` | ‚ùå | ‚ùå | ‚ùå | ‚ùå | N/A | Use exec form, not shell |
| `scratch` | ‚ùå | ‚ùå | ‚ùå | ‚ùå | N/A | Static binary health checks only |

*"Usually included" ‚â† guaranteed. Always verify with `docker run --rm <image> which <tool>`*

**Critical Rules**:

```
IF base_image CONTAINS "alpine":
    MUST explicitly install ALL health check tools
    NEVER assume availability of curl, wget, bash, nc

IF base_image CONTAINS "distroless":
    MUST use exec form for HEALTHCHECK (array syntax)
    CANNOT use shell utilities (curl, wget)
    Example: HEALTHCHECK CMD ["/app/healthcheck"]

IF base_image == "scratch":
    MUST compile health check into static binary
    OR use external monitoring (no HEALTHCHECK)
```

**Correct Patterns**:

**Alpine (Node.js)**:
```dockerfile
FROM node:22-alpine

# Install health check dependencies FIRST
RUN apk add --no-cache curl

WORKDIR /app
COPY package*.json ./
RUN npm ci --omit=dev
COPY . .

HEALTHCHECK --interval=30s --timeout=3s --start-period=15s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

CMD ["node", "server.js"]
```

**Alpine (Python)**:
```dockerfile
FROM python:3.11-alpine

# Install health check dependencies
RUN apk add --no-cache curl

WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .

HEALTHCHECK CMD curl -f http://localhost:8000/health || exit 1

CMD ["python", "app.py"]
```

**Distroless (Static Binary)**:
```dockerfile
# Build stage
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY . .
RUN go build -o server .
RUN go build -o healthcheck ./cmd/healthcheck

# Production (distroless - no shell)
FROM gcr.io/distroless/static-debian11

COPY --from=builder /app/server /server
COPY --from=builder /app/healthcheck /healthcheck

# Exec form (no shell) - required for distroless
HEALTHCHECK --interval=10s --timeout=3s \
  CMD ["/healthcheck"]

CMD ["/server"]
```

**Incorrect Patterns** (WILL FAIL):

**‚ùå Alpine without dependency install**:
```dockerfile
FROM node:22-alpine
WORKDIR /app
COPY . .

# Missing: RUN apk add --no-cache curl

HEALTHCHECK CMD curl -f http://localhost:3000/health || exit 1  # Runtime error
CMD ["node", "server.js"]
```

**‚ùå Multi-stage build installing in wrong stage**:
```dockerfile
# Build stage
FROM node:22-alpine AS builder
RUN apk add --no-cache curl  # ‚ùå WRONG STAGE
WORKDIR /app
COPY . .
RUN npm run build

# Production stage (curl not available here!)
FROM node:22-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist

HEALTHCHECK CMD curl -f http://localhost:3000/health || exit 1  # FAILS
CMD ["node", "dist/server.js"]
```

**‚úÖ Correct multi-stage**:
```dockerfile
# Build stage
FROM node:22-alpine AS builder
WORKDIR /app
COPY . .
RUN npm run build

# Production stage
FROM node:22-alpine
RUN apk add --no-cache curl  # ‚úÖ Install in FINAL stage
WORKDIR /app
COPY --from=builder /app/dist ./dist

HEALTHCHECK CMD curl -f http://localhost:3000/health || exit 1  # Works
CMD ["node", "dist/server.js"]
```

**Output**: Validation report showing health check tool availability + required Dockerfile additions

**Validation**:
- MUST test health check tool with `docker run --rm <image> which <tool>`
- Alpine/slim images MUST have explicit installation steps
- Multi-stage builds MUST install in FINAL production stage
- Distroless images MUST use exec form for HEALTHCHECK

**Invariants**:
- NEVER assume utilities exist without verification
- Alpine-based images REQUIRE explicit tool installation
- Multi-stage builds install tools in the stage that runs HEALTHCHECK
- Distroless/scratch images cannot use shell-based health checks

---

## PLAY: Audit Security

**Goal**: Check for vulnerabilities and apply safe fixes

**Trigger**: `/deps security` or `/deps audit`

**Algorithm**:
1. **Run security audit**:
   ```bash
   npm audit --json > audit-results.json
   ```

2. **Parse results**:
   ```javascript
   const audit = JSON.parse(fs.readFileSync('audit-results.json'))
   const critical = audit.vulnerabilities.filter(v => v.severity === 'critical')
   const high = audit.vulnerabilities.filter(v => v.severity === 'high')
   const moderate = audit.vulnerabilities.filter(v => v.severity === 'moderate')
   const low = audit.vulnerabilities.filter(v => v.severity === 'low')
   ```

3. **Display summary**:
   ```
   üîí SECURITY AUDIT RESULTS

   üî¥ CRITICAL (X):
   - CVE-XXXX: package@version (fix available: @safe-version)

   üü† HIGH (X):
   - CVE-YYYY: package@version (fix available: @safe-version)

   üü° MODERATE (X)
   üü¢ LOW (X)
   ```

4. **Categorize fixes**:
   - **Auto-fixable**: Patch/minor versions available
   - **Manual fix required**: Major version upgrade needed
   - **No fix available**: Mitigation strategies required

5. **Apply auto-fixes** (if --auto-fix flag):
   ```bash
   npm audit fix  # Safe fixes only (no breaking changes)
   ```

6. **For manual fixes**:
   - Display recommended actions
   - Prompt for each fix
   - Run PLAY: Update Risky for each package

7. **Validate after fixes**:
   ```bash
   npm audit  # Should show reduced vuln count
   npm run typecheck && npm run lint && npm test
   ```

8. **Generate report**:
   ```
   üìä SECURITY FIXES APPLIED

   ‚úÖ Auto-fixed: X vulnerabilities
   ‚ö†Ô∏è Manual review needed: Y vulnerabilities
   ‚ùå No fix available: Z vulnerabilities

   Validation:
   - Tests: PASSED
   - Type check: PASSED
   - Linting: PASSED
   ```

**Output**: Security fixes applied + validation report

**Invariants**:
- MUST NOT use `npm audit fix --force` without explicit approval
- MUST validate after applying fixes
- MUST report unfixable vulnerabilities with mitigation strategies

---

## PLAY: Emergency Patch

**Goal**: Fast-track critical security fixes with minimal validation

**Trigger**: `/deps emergency <CVE-ID>` or `/deps hotfix <package>`

**Risk Override**: Bypasses normal validation for critical security patches

**Algorithm**:
1. **Verify emergency status**:
   ```bash
   npm audit | grep CRITICAL
   if [ $? -ne 0 ]; then
     echo "‚ö†Ô∏è No critical vulnerabilities detected. Use /deps update instead."
     exit 1
   fi
   ```

2. **Display emergency context**:
   ```
   üö® EMERGENCY SECURITY PATCH

   CVE: <CVE-ID>
   Severity: CRITICAL
   Package: <package>@<vulnerable-version>
   Fix: <package>@<safe-version>

   This will bypass full validation. Proceed? (y/n)
   ```

3. **Apply fix immediately**:
   ```bash
   npm install <package>@<safe-version>
   ```

4. **Minimal validation**:
   ```bash
   npm run typecheck  # Type safety only
   npm test -- --run  # Quick test run (no coverage)
   ```

5. **Commit with emergency tag**:
   ```bash
   git add package.json package-lock.json
   git commit -m "security(deps): emergency patch for <CVE-ID>

   CRITICAL: <description>

   - Updated <package>: <old> ‚Üí <new>
   - Minimal validation applied (typecheck + tests)
   - Full validation required in follow-up

   [EMERGENCY PATCH]"
   ```

6. **Deploy immediately**:
   ```bash
   docker-compose build
   docker-compose up -d
   ```

7. **Schedule follow-up**:
   ```
   ‚ö†Ô∏è EMERGENCY PATCH APPLIED

   Next steps (required):
   1. Run full test suite: npm test
   2. Run integration tests: npm run test:integration
   3. Manual testing in staging
   4. Monitor production logs for 24h
   ```

**Output**: Emergency patch deployed + follow-up checklist

**Invariants**:
- ONLY for CRITICAL severity vulnerabilities
- MUST run minimal validation (typecheck + tests)
- MUST create follow-up task for full validation
- MUST tag commit with [EMERGENCY PATCH]

---

## PLAY: Validate Installation

**Goal**: Run comprehensive validation after any dependency update

**Trigger**: Automatically after PLAY: Update Safe/Risky, or `/deps validate`

**Algorithm**:
1. **Type check**:
   ```bash
   npm run typecheck
   # Exit code 0 = pass, non-zero = fail
   ```

2. **Linting**:
   ```bash
   npm run lint
   ```

3. **Unit tests**:
   ```bash
   npm test -- --run --coverage
   # Check coverage thresholds
   ```

4. **Integration tests** (if applicable):
   ```bash
   npm run test:integration
   ```

5. **Docker build test**:
   ```bash
   docker-compose build
   # Verify build succeeds with new dependencies
   ```

6. **Smoke tests**:
   ```bash
   docker-compose up -d
   curl http://localhost:3000/health  # Health check
   docker-compose down
   ```

7. **Collect results**:
   ```javascript
   const results = {
     typecheck: exitCode === 0,
     linting: exitCode === 0,
     tests: exitCode === 0 && coverage >= threshold,
     integration: exitCode === 0,
     docker: exitCode === 0,
     smoke: response.status === 200
   }
   ```

8. **Generate validation report**:
   ```
   ‚úÖ VALIDATION RESULTS

   ‚úÖ Type check: PASSED
   ‚úÖ Linting: PASSED
   ‚úÖ Tests: PASSED (X/X, coverage: Y%)
   ‚úÖ Integration tests: PASSED
   ‚úÖ Docker build: PASSED
   ‚úÖ Smoke tests: PASSED

   All validations passed. Safe to commit.
   ```

**Output**: Validation report (pass/fail)

**Validation**:
- ALL checks must pass for overall PASS
- Coverage must meet threshold (currently 80%)
- Docker build must succeed
- Health check must return 200

---

## I/O Contracts

### File Paths (Absolute)
- `/home/luce/apps/hex/package.json` - NPM dependencies
- `/home/luce/apps/hex/package-lock.json` - Locked versions
- `/home/luce/apps/hex/.nvmrc` - Node version
- `/home/luce/apps/hex/Dockerfile` - Docker base images (lines 2, 15)
- `/home/luce/apps/hex/docker-compose.typesense.yml` - Typesense version (line 3)

### Command Format
```bash
/deps <play> [<package>[@version]] [flags]

Plays:
  check | status          - Show dependency status
  update [--safe]        - Update dependencies
  update <pkg>[@ver]     - Update specific package
  align-node <version>   - Align Node versions
  security | audit       - Security audit + fixes
  emergency <CVE>        - Emergency security patch
  validate               - Run validation suite

Flags:
  --safe                 - Only patch versions
  --validate             - Full validation after update
  --auto-fix             - Auto-apply security fixes
  --force                - Skip confirmation prompts
  --dry-run              - Preview changes only
```

### Output Format
All status outputs use structured format:
```
üì¶ <SECTION HEADER>

<emoji> <CATEGORY> (X items):
- Item 1
- Item 2

Validation:
- Check 1: PASSED/FAILED
```

---

## Invariants

1. **NEVER manually edit**: package-lock.json, node_modules/
2. **ALWAYS commit together**: package.json + package-lock.json
3. **MUST align Node versions**: .nvmrc == package.json engines == Dockerfile
4. **HIGH-risk updates MUST run**: Integration tests before commit
5. **MCP SDK updates MUST test**: Real client compatibility
6. **Typesense updates MUST run**: Contract tests
7. **NEVER use --force**: Without explicit user confirmation
8. **EMERGENCY patches MUST create**: Follow-up validation task
9. **ALL updates MUST pass**: Typecheck + lint + tests before commit
10. **Validation failures MUST**: Rollback changes automatically
11. **Docker HEALTHCHECK MUST verify tool availability**: Never assume curl/wget/nc exist in base image, especially Alpine variants
12. **Alpine images MUST explicitly install health check tools**: `apk add --no-cache <tool>` required before HEALTHCHECK
13. **Multi-stage Docker builds MUST install tools in FINAL stage**: Tools must be in the stage where HEALTHCHECK executes

---

## Error Handling

### Missing Files
```bash
if [ ! -f package.json ]; then
  echo "‚ùå package.json not found. Are you in the project root?"
  exit 1
fi
```

### Uncommitted Changes
```bash
if [ -n "$(git status --porcelain)" ]; then
  echo "‚ö†Ô∏è Uncommitted changes detected"
  echo "Commit or stash changes before updating dependencies"
  exit 1
fi
```

### Validation Failures
```bash
if [ $typecheck_exit -ne 0 ] || [ $lint_exit -ne 0 ] || [ $test_exit -ne 0 ]; then
  echo "‚ùå Validation failed. Rolling back..."
  git checkout package.json package-lock.json
  npm install
  exit 1
fi
```

### Network Failures
```bash
npm install || {
  echo "‚ùå npm install failed (network error?)"
  echo "Retrying with --prefer-offline..."
  npm install --prefer-offline
}
```

### Docker Build Failures
```bash
docker-compose build || {
  echo "‚ùå Docker build failed"
  echo "Check Dockerfile and base image availability"
  exit 1
}
```

### HEALTHCHECK Tool Not Available at Runtime
```bash
# Symptom: Container builds successfully but health checks fail at runtime
# Root cause: Base image doesn't include required tool (curl, wget, nc, etc.)

# Extract HEALTHCHECK command from Dockerfile
HEALTHCHECK_CMD=$(grep "HEALTHCHECK" Dockerfile | grep -oP '(?<=CMD ).*?(?= \|\||$)' | awk '{print $1}')
BASE_IMAGE=$(grep "^FROM" Dockerfile | tail -1 | awk '{print $2}')

# Test if tool exists in base image
docker run --rm $BASE_IMAGE which $HEALTHCHECK_CMD

if [ $? -ne 0 ]; then
  echo "‚ùå HEALTHCHECK will fail at runtime"
  echo "Tool '$HEALTHCHECK_CMD' not found in $BASE_IMAGE"
  echo ""
  echo "Fix: Add installation to Dockerfile BEFORE HEALTHCHECK:"

  # Detect package manager and suggest fix
  if [[ "$BASE_IMAGE" == *"alpine"* ]]; then
    echo "  RUN apk add --no-cache $HEALTHCHECK_CMD"
  elif [[ "$BASE_IMAGE" == *"debian"* ]] || [[ "$BASE_IMAGE" == *"ubuntu"* ]]; then
    echo "  RUN apt-get update && apt-get install -y $HEALTHCHECK_CMD && rm -rf /var/lib/apt/lists/*"
  else
    echo "  (Install $HEALTHCHECK_CMD using your base image's package manager)"
  fi

  exit 1
fi
```

**Common scenarios**:
- **Alpine**: Missing curl, wget, bash ‚Üí Use `apk add --no-cache <tool>`
- **Debian slim**: Missing curl, wget ‚Üí Use `apt-get install -y <tool>`
- **Distroless**: No package manager ‚Üí Switch to base image with shell access or use TCP health checks
- **Multi-stage builds**: Tool installed in builder stage but not in final stage ‚Üí Install in FINAL stage

---

## Testing Checklist

- [ ] `/deps check` shows accurate status
- [ ] `/deps update --safe` only updates patch versions
- [ ] `/deps update <pkg>` validates correctly
- [ ] Node version alignment works (.nvmrc, package.json, Dockerfile)
- [ ] Security audit detects vulnerabilities
- [ ] Auto-fix applies safe patches only
- [ ] Manual fix prompts for HIGH-risk packages
- [ ] Emergency patch bypasses full validation
- [ ] Rollback works on validation failure
- [ ] All validation checks pass before commit
- [ ] Docker build succeeds after updates
- [ ] Docker HEALTHCHECK tool availability verified in base image
- [ ] MCP SDK updates test with real client
- [ ] Typesense updates run contract tests
- [ ] Dry-run mode previews without applying changes
- [ ] Commit messages follow conventional format

---

## Performance Considerations

### Typical Performance
- Status check: <5 seconds
- Safe update: 30-60 seconds (npm install + tests)
- Risky update: 1-3 minutes (changelog review + validation)
- Security audit: <10 seconds
- Full validation: 1-2 minutes (typecheck + lint + tests + docker)

### Optimization Strategies
- Cache npm dependencies in CI/CD
- Run validation checks in parallel where safe
- Skip integration tests for LOW-risk updates
- Use `--prefer-offline` for faster installs

### Scaling Limits
- Max packages: Unlimited (npm handles)
- Max parallel updates: 1 (avoid conflicts)
- Docker rebuild: ~2 minutes (depends on base image size)

---

## Explicit Non-Goals

- This playbook does NOT manage system-level dependencies (Python, Ruby, etc.)
- This playbook does NOT handle database migrations
- This playbook does NOT manage deployment infrastructure
- This playbook does NOT auto-merge dependency PRs (Dependabot integration out of scope)
- This playbook does NOT manage monorepo workspaces (single package.json only)

---

## Appendix A ‚Äî Dependency & Version Control Files to Check

This appendix is **project-agnostic** and applies to any software repository.
During audits, upgrades, or new technology intake, **every file listed here must be considered**.
Not all files will exist in every project; the checklist is intentionally exhaustive.

Use this appendix as a **scan list**, not a mandate.

---

### A.1 JavaScript / TypeScript (Node.js Ecosystem)

#### Core Dependency & Locking
- `package.json`
- `package-lock.json`
- `yarn.lock`
- `pnpm-lock.yaml`
- `.npmrc`
- `.yarnrc.yml`
- `.pnpmfile.cjs`

#### Runtime Version Pinning
- `.nvmrc`
- `.node-version`
- `volta.json`
- `engines` field in `package.json`

#### Build, Lint, Test, and Tooling Config
These often encode **implicit dependency and runtime assumptions**.
- `tsconfig.json`
- `eslint.config.js`
- `.eslintrc.*`
- `vitest.config.ts`
- `jest.config.*`
- `babel.config.*`
- `webpack.config.*`
- `vite.config.*`
- `rollup.config.*`

#### Hidden / Transitive Tool Configs (Inspect, Do Not Edit)
- `node_modules/**/eslint.config.*`
- `node_modules/**/.eslintrc.*`
- `node_modules/**/tsconfig.json`

These can surface errors during upgrades but should **never be edited directly**.

---

### A.2 Python

#### Dependency & Locking
- `requirements.txt`
- `requirements-dev.txt`
- `pyproject.toml`
- `poetry.lock`
- `Pipfile`
- `Pipfile.lock`
- `setup.py`
- `setup.cfg`

#### Runtime & Environment
- `.python-version`
- `runtime.txt`
- `tox.ini`

#### Linting, Typing, Testing
- `ruff.toml`
- `.flake8`
- `mypy.ini`
- `pytest.ini`

---

### A.3 Go

#### Module System
- `go.mod`
- `go.sum`

#### Tooling & CI Integration
- `tools.go`
- `.golangci.yml`
- `Makefile` (often pins tool versions)

---

### A.4 Java / JVM (Java, Kotlin, Scala)

#### Dependency & Build
- `pom.xml`
- `build.gradle`
- `build.gradle.kts`
- `settings.gradle`
- `gradle.properties`
- `gradlew`
- `gradlew.bat`

#### Version Management
- `versions.properties`
- BOM (Bill of Materials) files

---

### A.5 .NET

#### Dependency & SDK Pinning
- `.csproj`
- `.fsproj`
- `.vbproj`
- `packages.config`
- `Directory.Build.props`
- `Directory.Build.targets`
- `global.json`
- `nuget.config`

---

### A.6 Rust

#### Dependency & Locking
- `Cargo.toml`
- `Cargo.lock`

#### Tooling
- `rust-toolchain.toml`
- `clippy.toml`

---

### A.7 Ruby

#### Dependency & Runtime
- `Gemfile`
- `Gemfile.lock`
- `.gemspec`
- `.ruby-version`

---

### A.8 Containers & Infrastructure (Cross-Language)

#### Containers
- `Dockerfile`
- `.dockerignore`
- `docker-compose.yml`
- `docker-compose.*.yml`

#### Infrastructure as Code
- `terraform.lock.hcl`
- `main.tf`
- `providers.tf`
- `Pulumi.yaml`
- `Pulumi.<env>.yaml`
- `helm/Chart.yaml`
- `helm/Chart.lock`
- `kustomization.yaml`

These files frequently pin:
- Base images
- Provider versions
- Platform constraints

---

### A.9 CI / Automation Pipelines (High-Risk Drift Zone)

#### Common CI Files
- `.github/workflows/*.yml`
- `.gitlab-ci.yml`
- `azure-pipelines.yml`
- `.circleci/config.yml`

#### Audit Focus
- Hard-pinned action versions
- Deprecated runners
- Language setup actions
- Cache keys tied to old lockfile formats

---

### A.10 Dependency Update Automation & Security Scanners

These govern **how upgrades happen**, not what dependencies exist.
- `.github/dependabot.yml`
- `dependabot.yml`
- `.snyk`
- `renovate.json`
- `renovate.json5`
- `osv-scanner.toml`

These files must evolve as the dependency graph and repo layout change.

---

### A.11 Monorepo / Workspace Management

If present, these **silently influence dependency resolution**:
- `pnpm-workspace.yaml`
- `lerna.json`
- `nx.json`
- `turbo.json`
- `rush.json`
- Yarn workspaces config

---

### A.12 Generated State & Artifact Directories (Classification Required)

Not files, but **directories that require explicit policy**:
- `dist/`
- `build/`
- `out/`
- `tmp/`
- `.cache/`
- `logs/`
- `.next/`, `.vite/`, `.turbo/`, `.nx/`
- Local database or service data directories

Each must be explicitly classified as:
- **Versioned**
- **Ignored**
- **Conditionally versioned (rare)**

---

### A.13 Decision Matrix: When to Update Each File Type

This matrix defines **triggers** for updating dependency-related files.

| File Type | Update Trigger | Test Criteria | Skip Condition |
|-----------|---------------|---------------|----------------|
| **Lockfiles** (package-lock.json, etc.) | Every dependency update | Build succeeds + tests pass | Never skip (auto-generated) |
| **Runtime pinning** (.nvmrc, .python-version) | Major/minor runtime upgrade | Cross-reference with Dockerfile, package.json engines | Only if runtime unchanged |
| **Tooling config** (tsconfig.json, eslint.config.js) | When tool reports version errors | TypeScript compiles + Linter passes | If tool version unchanged |
| **CI pipelines** (.github/workflows/*.yml) | Action deprecation warning or dependency bump | CI build passes on branch | If actions/images pinned and working |
| **Container images** (Dockerfile) | Base image security update or runtime bump | Docker build + integration tests pass | If using `latest` tag (not recommended) |
| **IaC files** (terraform.lock.hcl) | Provider version change or security patch | `terraform plan` shows expected changes only | If locked versions still supported |
| **Security scanners** (dependabot.yml, .snyk) | New vulnerability discovered or scanner upgrade | Scanner runs without errors | If scanner config static and working |
| **Monorepo workspaces** (pnpm-workspace.yaml) | Workspace structure changes | All workspaces resolve + build | If workspace topology unchanged |

**Decision Algorithm**:

```
IF dependency_update OR runtime_bump OR new_technology:
    FOR each file_type IN appendix_sections:
        IF update_trigger MATCHES current_change:
            RUN test_criteria
            IF tests_pass:
                MARK file AS "verified"
            ELSE:
                UPDATE file
                RERUN test_criteria
                IF still_fails:
                    ROLLBACK change
                    ESCALATE to manual review
        ELSE:
            IF skip_condition NOT met:
                VERIFY file unchanged since last audit
                MARK file AS "unchanged_verified"
```

---

### A.14 Test Procedures by File Category

#### Lockfiles (package-lock.json, poetry.lock, etc.)

**Test Procedure**:
```bash
# 1. Delete lockfile
rm package-lock.json

# 2. Regenerate from package.json
npm install

# 3. Verify build
npm run build

# 4. Run tests
npm test

# 5. Compare lockfile diff
git diff package-lock.json
```

**Pass Criteria**:
- Build completes without errors
- All tests pass
- No unexpected version jumps in lockfile diff

---

#### Runtime Pinning (.nvmrc, .python-version, Dockerfile)

**Test Procedure**:
```bash
# 1. Check version alignment
NODE_VERSION_NVMRC=$(cat .nvmrc)
NODE_VERSION_DOCKERFILE=$(grep "FROM node:" Dockerfile | grep -oP 'node:\K[0-9.]+')
NODE_VERSION_PACKAGE=$(node -pe "require('./package.json').engines.node")

# 2. Report misalignments
echo "nvmrc: $NODE_VERSION_NVMRC"
echo "Dockerfile: $NODE_VERSION_DOCKERFILE"
echo "package.json: $NODE_VERSION_PACKAGE"

# 3. If misaligned, update all three to match
# 4. Rebuild Docker image
docker build -t test-image .

# 5. Run integration tests
docker run test-image npm test
```

**Pass Criteria**:
- All three sources declare same major.minor version
- Docker image builds successfully
- Tests pass inside container

---

#### Tooling Config (tsconfig.json, eslint.config.js, vitest.config.ts)

**Test Procedure**:
```bash
# 1. Verify TypeScript config
npx tsc --noEmit

# 2. Verify ESLint config
npx eslint . --max-warnings 0

# 3. Verify test config
npm test

# 4. Check for deprecated options
npx tsc --showConfig | grep -i deprecated
```

**Pass Criteria**:
- No TypeScript errors
- No ESLint warnings above threshold
- Tests execute and pass
- No deprecation warnings in output

---

#### CI Pipelines (.github/workflows/*.yml)

**Test Procedure**:
```bash
# 1. Validate YAML syntax
yamllint .github/workflows/*.yml

# 2. Check for deprecated actions
grep "uses:" .github/workflows/*.yml | grep -v "@v" | grep -v "@sha"

# 3. Trigger test workflow
git push --set-upstream origin test-branch

# 4. Monitor CI run
gh run watch
```

**Pass Criteria**:
- YAML is valid
- All actions use pinned versions (@v2, @sha256:...)
- CI workflow completes successfully
- No deprecation warnings in logs

---

#### Container Images (Dockerfile, docker-compose.yml)

**Test Procedure**:
```bash
# 1. Scan for vulnerabilities
docker scout cves Dockerfile

# 2. Build image
docker build -t audit-test .

# 3. Check image size (flag regressions)
docker images audit-test --format "{{.Size}}"

# 4. Run smoke tests
docker run audit-test npm test

# 5. Verify multi-stage builds (if applicable)
docker build --target production -t audit-test-prod .
```

**Pass Criteria**:
- No high/critical CVEs in base image
- Image size within expected range (¬±10% of baseline)
- Smoke tests pass
- Production target builds successfully

---

### A.15 Reporting Template

After running audit, generate report in this format:

```markdown
# Dependency Audit Report

**Date**: YYYY-MM-DD
**Trigger**: [Dependency update | Runtime bump | New technology | Scheduled audit]
**Auditor**: [Name or automation system]

---

## Summary

| Category | Files Found | Files Updated | Files Verified | Issues Found |
|----------|-------------|---------------|----------------|--------------|
| JS/TS    | 12          | 2             | 10             | 0            |
| Python   | 0           | 0             | 0              | N/A          |
| Containers | 3         | 1             | 2              | 1            |
| CI/CD    | 5           | 0             | 5              | 0            |
| **Total** | **20**     | **3**         | **17**         | **1**        |

---

## Files Updated

### 1. package-lock.json
- **Reason**: Dependency upgrade (vitest 1.0.0 ‚Üí 2.0.0)
- **Changes**: 47 packages updated
- **Tests**: ‚úÖ All pass
- **Validated**: 2025-12-30

### 2. Dockerfile
- **Reason**: Node 20 ‚Üí Node 22 alignment
- **Changes**: `FROM node:20-alpine` ‚Üí `FROM node:22-alpine`
- **Tests**: ‚úÖ Build + integration tests pass
- **Validated**: 2025-12-30

---

## Issues Found

### Issue #1: Dockerfile base image has CVE-2024-12345
- **Severity**: HIGH
- **File**: Dockerfile
- **Description**: Base image `node:22-alpine` contains vulnerability in OpenSSL
- **Resolution**: Pending upstream patch, added to watchlist
- **Workaround**: Pinned to `node:22.1.0-alpine` (patched version)

---

## Files Verified Unchanged

- .nvmrc (Node 22 - matches Dockerfile)
- package.json engines field (>=22.0.0)
- tsconfig.json (no TypeScript version change)
- vitest.config.ts (compatible with vitest 2.0.0)
- .github/workflows/test.yml (no action updates needed)

---

## Recommendations

1. **HIGH**: Upgrade `node:22-alpine` when CVE-2024-12345 is patched (ETA: 2025-01-15)
2. **MEDIUM**: Consider migrating from `.nvmrc` to `volta.json` for team consistency
3. **LOW**: Add `.node-version` for broader tool support (nvm, asdf, fnm)

---

## Next Audit

**Scheduled**: 2025-01-30 (monthly cadence)
**Trigger**: Automatic (calendar) or earlier if critical CVE discovered
```

---

### A.16 Update Criteria & Thresholds

**When to update immediately** (EMERGENCY):
- Critical CVE (CVSS ‚â• 9.0) in runtime or base image
- Build/CI complete failure blocking development
- Security scanner blocking deploy

**When to update in next sprint** (HIGH):
- Major version bump of critical dependency (MCP SDK, TypeScript)
- Medium CVE (CVSS 7.0-8.9) with available patch
- CI action deprecated with sunset date < 90 days

**When to update opportunistically** (MEDIUM):
- Minor version bumps of dev tools
- Low CVE (CVSS 4.0-6.9) with workaround
- Lockfile drift (>50 outdated packages)

**When to defer** (LOW):
- Patch version bumps with no security impact
- Tooling config that works and has no deprecation warnings
- CI actions still supported for >6 months

**Document deferral reasoning**:
```markdown
## Deferred Updates

| File | Current | Available | Reason for Deferral | Review Date |
|------|---------|-----------|---------------------|-------------|
| typescript | 5.3.3 | 5.4.2 | Breaking changes in 5.4, assess in Q2 | 2025-04-01 |
```

---

### A.17 Appendix Enforcement Rule

When a dependency upgrade, runtime bump, or new technology is introduced:

1. **Scan this entire appendix**
2. **Identify which files apply**
3. **Explicitly confirm each applicable file is either:**
   - Verified unchanged
   - Updated intentionally
   - Documented as not applicable

If a failure occurs during or after an upgrade, the fix is often **in one of these files**, not the dependency itself.

This appendix exists to prevent:
- "We forgot that file"
- Silent runtime mismatches
- CI-only breakages
- Production-only failures
- Dependency drift masked by tooling

---

### A.14 Automated Audit Script

Run this script to scan your project for applicable dependency files:

```bash
#!/usr/bin/env bash
# deps-audit.sh - Scan project for dependency and version control files
# Usage: bash deps-audit.sh [project-root]
# Output: List of found files organized by category

set -euo pipefail

PROJECT_ROOT="${1:-.}"
cd "$PROJECT_ROOT"

echo "=== Dependency & Version Control File Audit ==="
echo "Project: $(pwd)"
echo "Date: $(date)"
echo ""

# A.1 JavaScript/TypeScript
echo "## A.1 JavaScript/TypeScript (Node.js)"
find . -maxdepth 3 -type f \( \
  -name "package.json" -o \
  -name "package-lock.json" -o \
  -name "yarn.lock" -o \
  -name "pnpm-lock.yaml" -o \
  -name ".npmrc" -o \
  -name ".yarnrc.yml" -o \
  -name ".pnpmfile.cjs" -o \
  -name ".nvmrc" -o \
  -name ".node-version" -o \
  -name "volta.json" -o \
  -name "tsconfig.json" -o \
  -name "eslint.config.js" -o \
  -name ".eslintrc.*" -o \
  -name "vitest.config.ts" -o \
  -name "jest.config.*" -o \
  -name "babel.config.*" -o \
  -name "webpack.config.*" -o \
  -name "vite.config.*" -o \
  -name "rollup.config.*" \
\) 2>/dev/null | sort || echo "  (none found)"
echo ""

# A.2 Python
echo "## A.2 Python"
find . -maxdepth 3 -type f \( \
  -name "requirements.txt" -o \
  -name "requirements-dev.txt" -o \
  -name "pyproject.toml" -o \
  -name "poetry.lock" -o \
  -name "Pipfile" -o \
  -name "Pipfile.lock" -o \
  -name "setup.py" -o \
  -name "setup.cfg" -o \
  -name ".python-version" -o \
  -name "runtime.txt" -o \
  -name "tox.ini" -o \
  -name "ruff.toml" -o \
  -name ".flake8" -o \
  -name "mypy.ini" -o \
  -name "pytest.ini" \
\) 2>/dev/null | sort || echo "  (none found)"
echo ""

# A.3 Go
echo "## A.3 Go"
find . -maxdepth 3 -type f \( \
  -name "go.mod" -o \
  -name "go.sum" -o \
  -name "tools.go" -o \
  -name ".golangci.yml" \
\) 2>/dev/null | sort || echo "  (none found)"
echo ""

# A.4 Java/JVM
echo "## A.4 Java/JVM"
find . -maxdepth 3 -type f \( \
  -name "pom.xml" -o \
  -name "build.gradle" -o \
  -name "build.gradle.kts" -o \
  -name "settings.gradle" -o \
  -name "gradle.properties" -o \
  -name "gradlew" -o \
  -name "gradlew.bat" -o \
  -name "versions.properties" \
\) 2>/dev/null | sort || echo "  (none found)"
echo ""

# A.5 .NET
echo "## A.5 .NET"
find . -maxdepth 3 -type f \( \
  -name "*.csproj" -o \
  -name "*.fsproj" -o \
  -name "*.vbproj" -o \
  -name "packages.config" -o \
  -name "Directory.Build.props" -o \
  -name "Directory.Build.targets" -o \
  -name "global.json" -o \
  -name "nuget.config" \
\) 2>/dev/null | sort || echo "  (none found)"
echo ""

# A.6 Rust
echo "## A.6 Rust"
find . -maxdepth 3 -type f \( \
  -name "Cargo.toml" -o \
  -name "Cargo.lock" -o \
  -name "rust-toolchain.toml" -o \
  -name "clippy.toml" \
\) 2>/dev/null | sort || echo "  (none found)"
echo ""

# A.7 Ruby
echo "## A.7 Ruby"
find . -maxdepth 3 -type f \( \
  -name "Gemfile" -o \
  -name "Gemfile.lock" -o \
  -name "*.gemspec" -o \
  -name ".ruby-version" \
\) 2>/dev/null | sort || echo "  (none found)"
echo ""

# A.8 Containers & Infrastructure
echo "## A.8 Containers & Infrastructure"
find . -maxdepth 3 -type f \( \
  -name "Dockerfile" -o \
  -name ".dockerignore" -o \
  -name "docker-compose.yml" -o \
  -name "docker-compose.*.yml" -o \
  -name "terraform.lock.hcl" -o \
  -name "main.tf" -o \
  -name "providers.tf" -o \
  -name "Pulumi.yaml" -o \
  -name "Pulumi.*.yaml" -o \
  -name "Chart.yaml" -o \
  -name "Chart.lock" -o \
  -name "kustomization.yaml" \
\) 2>/dev/null | sort || echo "  (none found)"
echo ""

# A.9 CI/CD Pipelines
echo "## A.9 CI/CD Pipelines"
find . -maxdepth 4 -type f \( \
  -path "./.github/workflows/*.yml" -o \
  -path "./.github/workflows/*.yaml" -o \
  -name ".gitlab-ci.yml" -o \
  -name "azure-pipelines.yml" -o \
  -path "./.circleci/config.yml" \
\) 2>/dev/null | sort || echo "  (none found)"
echo ""

# A.10 Dependency Automation
echo "## A.10 Dependency Update Automation"
find . -maxdepth 3 -type f \( \
  -name "dependabot.yml" -o \
  -path "./.github/dependabot.yml" -o \
  -name ".snyk" -o \
  -name "renovate.json" -o \
  -name "renovate.json5" -o \
  -name "osv-scanner.toml" \
\) 2>/dev/null | sort || echo "  (none found)"
echo ""

# A.11 Monorepo/Workspace
echo "## A.11 Monorepo/Workspace Management"
find . -maxdepth 3 -type f \( \
  -name "pnpm-workspace.yaml" -o \
  -name "lerna.json" -o \
  -name "nx.json" -o \
  -name "turbo.json" -o \
  -name "rush.json" \
\) 2>/dev/null | sort || echo "  (none found)"
echo ""

# A.12 Generated Directories
echo "## A.12 Generated State & Artifact Directories"
find . -maxdepth 2 -type d \( \
  -name "dist" -o \
  -name "build" -o \
  -name "out" -o \
  -name "tmp" -o \
  -name ".cache" -o \
  -name "logs" -o \
  -name ".next" -o \
  -name ".vite" -o \
  -name ".turbo" -o \
  -name ".nx" \
\) 2>/dev/null | sort || echo "  (none found)"
echo ""

echo "=== Audit Complete ==="
echo ""
echo "NEXT STEPS:"
echo "1. Review each file for version consistency"
echo "2. Check for hardcoded versions in tooling configs"
echo "3. Verify CI/CD pipelines use current actions/images"
echo "4. Confirm generated directories are properly ignored in .gitignore"
```

**Usage**:

```bash
# Run from project root
bash .claude/scripts/deps-audit.sh

# Run from different location
bash .claude/scripts/deps-audit.sh /path/to/project

# Save audit report
bash .claude/scripts/deps-audit.sh > deps-audit-report.txt
```

**Integration with /deps command**:

```bash
# Check all dependency files before major upgrade
/deps status --audit-files

# This would trigger:
# 1. Run deps-audit.sh
# 2. Compare current state with git history
# 3. Flag files modified since last dependency update
# 4. Report misalignments (e.g., Dockerfile Node != .nvmrc)
```

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.2 | 2025-12-30 | **Dry-Run Mode**: Added PLAY: Dry-Run Preview for safe preview of changes before execution. Supports `--dry-run` flag on all update commands. Shows planned changes, risk assessment, validation steps, and impact estimates without modifying files. Updated slash command with dry-run examples. |
| 1.1 | 2025-12-30 | **Appendix A Enhancement**: Added comprehensive dependency governance framework with 7 new sections: (A.13) Decision Matrix for when to update each file type, (A.14) Test Procedures by file category with pass criteria, (A.15) Reporting Template for audit results, (A.16) Update Criteria & Thresholds (EMERGENCY/HIGH/MEDIUM/LOW), (A.17) Enforcement Rule. Covers 12 ecosystems (JS/TS, Python, Go, Java, .NET, Rust, Ruby, Containers, CI/CD, Security, Monorepo, Generated artifacts) with automated audit script (deps-audit.sh). Addresses HOW to test, WHAT to update, WHEN to act, and HOW to report findings. |
| 1.0 | 2025-12-30 | Initial playbook: 7 plays (Check Status, Update Safe, Update Risky, Align Versions, Audit Security, Emergency Patch, Validate Installation). Risk-aware workflows (LOW/MEDIUM/HIGH/EMERGENCY tiers). Comprehensive validation (typecheck, lint, tests, integration, Docker build). |

---

**Maintained by**: Project maintainers
**Source**: [docs/DEPENDENCY-MANIFEST.md](docs/DEPENDENCY-MANIFEST.md)
**Status**: Production standard for all dependency updates
